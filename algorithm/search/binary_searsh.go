package search

// Для каждого покупателя выведите в отдельной строке количество тетрадей, которые он приобрёл.
// nums количества тетрадей в каждой партии
// n - количество партий тетрадей
// y - количество тетрадей, которое хочет купить каждый покупатель.
// найдём в массиве наибольшее число, которое меньше или равно заданного.
func binsearch1(nums []int, n, y int) int {
	l := 0 // левая граница включительно
	r := n // правая граница не включительно
	for l != r-1 {
		mid := (l + r) / 2
		if nums[mid] > y {
			r = mid
		} else {
			l = mid
		}
	}

	if l == 0 && r == 1 {
		return 0
	}

	return nums[l]
}

// в массиве могут быть несколько равных элементов, и мы хотим найти их количество.
// Для начала мы можем найти самое левое вхождение элемента за O(log(n)), а после этого идти вправо до тех пор, пока не встретим элемент, неравный искомому.
// Но в худшем случае этот алгоритм будет работать за линейное время, например, когда весь массив состоит из одного и того же искомого числа.
// Поэтому мы кроме первого вхождения также можем найти самое правое вхождение элемента за  O(log(n)), а затем посчитать длину.
func countEqualItem(nums []int, n, y int) int {
	l := leftbin(nums, n, y)
	r := rightbin(nums, n, y)

	if l != -1 {
		return r - l + 1
	}

	return 0
}

// поиск самого правого индекса элемента в масиве если есть одинаковые
func rightbin(nums []int, n, y int) int {
	l := 0 // левая граница включительно
	r := n // правая граница не включительно
	for l != r-1 {
		mid := (l + r) / 2
		if nums[mid] > y {
			r = mid
		} else {
			l = mid
		}
	}
	if nums[l] == y { // если мы смогли найти элемент Y
		return l // возвращаем индекс его самого правого вхождения
	} else {
		return -1 // если такого элемента нет, вернем -1
	}
}

// поиск самого левого индекса элемента в масиве если есть одинаковые
func leftbin(nums []int, n, y int) int {
	l := -1    // левая граница не включительно
	r := n - 1 // правая граница включительно
	for l != r-1 {
		mid := (l + r) / 2
		if nums[mid] >= y {
			r = mid
		} else {
			l = mid
		}
	}
	if nums[r] == y { // правая включительно, поэтому в ней должен лежать искомый элемент
		return r // возвращаем индекс его самого левого вхождения
	} else {
		return -1 // если такого элемента нет, вернем -1
	}
}
